import { AVPlaybackStatus, Audio } from "expo-av";
import { useLocalSearchParams } from "expo-router";
import React, { useEffect, useState } from "react";
import { Button, H6, Slider, XStack, YStack, useTheme, Text } from "tamagui";
import {
  PlexAudiobook,
  PlexChapter,
  PlexPlayQueue,
} from "../../api/PlexClient";
import { State } from "@lukehagar/plexjs/src/models/operations";
import { Duration } from "luxon";
import { usePlexClient } from "../../utils/PlexClientProvider";
import AudiobookDetails from "../../components/AudiobookDetails";
import { PlayPauseIcon } from "./[key]";

export default function Audiobook() {
  const theme = useTheme();

  const [client] = usePlexClient();
  const [playback, setPlayback] = useState<Audio.Sound>();
  const [playbackStatus, setPlaybackStatus] = useState<AVPlaybackStatus>();
  const [audiobook, setAudiobook] = useState<PlexAudiobook>();
  const [queue, setQueue] = useState<PlexPlayQueue>();
  const [chapter, setChapter] = useState<PlexChapter>();
  // playback status is updated every 250ms, so update plex every 5s
  const PlexProgressUpdateIntervalMultiplier = 20;
  const [progressUpdateCount, setProgressUpdateCount] = useState<number>(
    PlexProgressUpdateIntervalMultiplier - 1,
  );

  const { key } = useLocalSearchParams<{ key: string }>();
  const ratingKey = Number(key!);

  useEffect(() => {
    const getData = async () => {
      // start the queue
      const [queue, audiobook] = await client.queueAudiobook(ratingKey);
      setAudiobook(audiobook);
      setQueue(queue);

      await Audio.setAudioModeAsync({ playsInSilentModeIOS: true });
      const { sound } = await Audio.Sound.createAsync(
        {
          uri: audiobook.uri!,
        },
        // undefined,
        {
          positionMillis: audiobook.viewOffset,
        },
        setPlaybackStatus,
      );
      setPlayback(sound);
    };
    getData();
  }, []);

  useEffect(() => {
    if (!playbackStatus?.isLoaded) return;

    const currentChapter = audiobook?.chapters?.find(
      (c) =>
        playbackStatus.positionMillis >= c.startTimeOffset &&
        playbackStatus.positionMillis <= c.endTimeOffset,
    );
    setChapter(currentChapter);

    if (progressUpdateCount == 0) {
      updatePlexProgress();
      setProgressUpdateCount(PlexProgressUpdateIntervalMultiplier);
    } else {
      setProgressUpdateCount(progressUpdateCount - 1);
    }
  }, [playbackStatus]);

  const updatePlexProgress = async () => {
    const status = playbackStatus;
    if (!status?.isLoaded || !audiobook || !queue) return;
    client.updateProgress(
      queue,
      status.positionMillis,
      status.isPlaying ? State.Playing : State.Paused,
    );
  };

  const togglePlay = () => {
    if (!playbackStatus?.isLoaded || !playback) return;

    if (playbackStatus.isPlaying) {
      playback.pauseAsync();
    } else {
      playback.playAsync();
    }
  };

  const handleSliderChange = (value: number[]) => {
    console.log("new value", value[0]);
  };

  if (!playbackStatus?.isLoaded || !playback || !audiobook) return;

  let progressPercent = Math.floor(
    (playbackStatus.positionMillis / audiobook.duration) * 100,
  );

  const formatPlaybackTime = (time: number) => {
    const dur = Duration.fromMillis(time);
    if (dur.as("hours") < 1) {
      return dur.toFormat("mm:ss");
    } else {
      return dur.toFormat("hh:mm:ss");
    }
  };

  let positionInChapter, chapterDuration;
  if (chapter) {
    positionInChapter = playbackStatus.positionMillis - chapter.startTimeOffset;
    chapterDuration = chapter.endTimeOffset - chapter.startTimeOffset;
    progressPercent = positionInChapter / chapterDuration;
    progressPercent = Math.floor(
      ((playbackStatus.positionMillis - chapter.startTimeOffset) /
        (chapter.endTimeOffset - chapter.startTimeOffset)) *
        100,
    );
  }
  return (
    <>
      {/* <Stack.Screen options={{ title: audiobook.title }} /> */}
      <YStack padding="$5" maxWidth={550}>
        <AudiobookDetails audiobook={audiobook} />
        <XStack alignSelf="center">
          <H6>{chapter?.tag}</H6>
        </XStack>
        <AudiobookPlayer />
        <XStack alignSelf="center" padding="$5">
          <Button
            onPress={togglePlay}
            backgroundColor={theme.purple4}
            icon={
              <PlayPauseIcon
                playing={playbackStatus.isPlaying}
                size="$4"
                fill={theme.color.val}
              />
            }
            size="$8"
            circular
          ></Button>
        </XStack>
        <XStack>
          <Slider
            defaultValue={[progressPercent]}
            value={[progressPercent]}
            onValueChange={handleSliderChange}
            max={100}
            step={1}
            flex={1}
          >
            <Slider.Track>
              <Slider.TrackActive />
            </Slider.Track>
            <Slider.Thumb
              size="$0.75"
              index={0}
              circular
              backgroundColor={theme.purple5}
              pressStyle={{
                borderColor: theme.purple5,
                backgroundColor: theme.color1,
              }}
              focusStyle={{
                borderColor: theme.purple5,
                backgroundColor: theme.color1,
              }}
            />
          </Slider>
        </XStack>
        <XStack alignSelf="flex-end">
          <Text>
            {formatPlaybackTime(playbackStatus.positionMillis)} /{" "}
            {formatPlaybackTime(audiobook.duration)}
          </Text>
        </XStack>
        {chapter && (
          <XStack alignSelf="flex-end">
            <Text>
              {formatPlaybackTime(positionInChapter!)} /{" "}
              {formatPlaybackTime(chapterDuration!)}
            </Text>
          </XStack>
        )}
      </YStack>
    </>
  );
}
